/**
 * @file marketplace.sol
 * @author Nachiket Tapas <ntapas@unime.it>
 * @date created 01 Jun 2020
 * @date last modified 09 Jul 2020
 */

pragma solidity ^0.5.0;

contract designVoting {
    //Constant variables for penalty and reward
    uint256 constant taup = 1;
    uint256 constant taur = 1;
    uint256 constant deltaExp = 1800; //30 minutes delta. Need to set it in seconds. 
    uint256 constant deltaReveal = 1800; //30 minutes delta. Need to set it in seconds.
    
    struct designState
    {
        address vendor;
        uint256 timestamp;
        uint256 expiry;
        uint256 balance;
        address manager;
    }

    //The vote is considered as follows
    // 0 : no vote. maybe due to time expired
    // -1 : invalid design
    // 1 : valid design
    struct playerState
    {
        uint256 reputation;
        uint256 weight;
        bytes32[] commitments;
        bytes32[] votes;
        bool[] received;
    }
   
    //Variable to store the address of the manager. Currently it is hard coded. 
    //Maybe it can be initialized in the announce function
    //address private manager = 0xDdaFe7494315d08378A8F96f6e6A0C681d2b1563;
   
    uint private results;
    //Mapping of design identified by creator/vendor index and collection of players indexes registered to vote
    mapping (uint256 => mapping (address => uint256)) private regPlayers;
    mapping (uint256 => uint256) private numRegistered;
    //Design details indexed by creator/vendor index
    mapping (uint256 => designState) private designes;
    uint256 private numDesignes = 0;
    //Player details indexed by player index
    mapping (uint256 => playerState) private players;
    uint256 private numPlayers = 0;
   
    event newDesign(bytes32 fileHash, uint256 designNo, address creator);
    event resultCalculated(bytes32 fileHash, uint256 designNo, address creator);
   
    event tempOutput(uint256 _output);//, uint256 timestamp, uint256 expiry, uint256 balance);

    //The commitment is send via the value field in the remix. If the sent value matches the commitment parameter,
    //the contract announces the availability of new design for verification.
    function announce(bytes32 _fileHash, uint256 _timestamp, uint256 _expiry, uint256 _commitment, address _manager)
        public payable
    {
        //Check for positive commitment
        require(_commitment > 0, "The commitment should be more than 0.");
       
        //Check if the commitment parameter matches the commiment sent to the contract.
        require(msg.value == _commitment, "The announcement didn't receive the commitment.");
       
        //Design index
        uint256 j = numDesignes;
       
        //Design creator
        designes[j].vendor = msg.sender;
       
        //Creation timestamp received from the js script
        designes[j].timestamp = _timestamp;
       
        //Expiry timestamp received from the js script
        designes[j].expiry = _expiry;
       
        //Commitment
        designes[j].balance = _commitment;
       
        //Set a manager
        designes[j].manager = _manager;
        
        //Incrementing the design index
        numDesignes = numDesignes + 1;
       
        //Emitting notification for new design creation.
        //Verifiers receiving the notification can participate in the process
        //Filehash to ensure file integrity
        //Index to use for search
        //Vendor address for source verification
        emit newDesign(_fileHash, j, msg.sender);
    }

    //In-case the design verification expires, the commitment is returned to the vendor.
    //Currently only the vendor can initiate the withdrawl.
    function withdraw(uint256 _amount, uint256 _designNo) public {
        //Check if the method initiator is the one who published the design
        require(msg.sender == designes[_designNo].vendor, "Only the publisher can initiate the withdrawl.");
       
        //Insert a check condition regarding the time before which the vendor cannot withdraw the commitment
        require(designes[_designNo].expiry <= now, "The balance can be withdrawn only after expiry.");
       
        //Check if the amount requested for withdrawl is less than balance
        require(_amount <= designes[_designNo].balance, "The withdrawl amount is more than the balance.");
       
        //Check for the withdrawl amount
        require(_amount > 0, "The withdrawl amount should be greater than 0.");
       
        //Reducing the balance and sending the withdrawl amount to the vendor
        designes[_designNo].balance -= _amount;
        msg.sender.transfer(_amount);
    }
   
    function addPlayer(bytes32 _hashMsg, bytes memory _signature) public {
        //Check for identity of the user registering
        (uint8 _v, bytes32 _r, bytes32 _s) = splitSignature(_signature);
        bytes memory prefix = "\x19Ethereum Signed Message:\n32";
        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashMsg));
        require(ecrecover(prefixedHash, _v + 27, _r, _s) == msg.sender, "The registration identity verification failed.");
        
        //Player index
        uint256 k = numPlayers;
        
        //Initialize player requesting registration
        players[k].reputation = 0;
        players[k].weight = 0;
        
        //Incrementing the player index
        numPlayers = numPlayers + 1;
    }
    
    //This function can be considered as expression of interest to take part in the voting and not to be confused with
    //player registration to the system.
    function register(bytes32 _hashMsg, bytes memory _signature, uint256 _designNo, uint256 _commitment)
        public payable
    {
        //Check for identity of the user registering
        (uint8 _v, bytes32 _r, bytes32 _s) = splitSignature(_signature);
        bytes memory prefix = "\x19Ethereum Signed Message:\n32";
        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashMsg));
        require(ecrecover(prefixedHash, _v + 27, _r, _s) == msg.sender, "The registration identity verification failed.");
        
        //Check for positive commitment
        require(_commitment > 0, "The commitment should be more than 0.");
       
        //Check if the commitment parameter matches the commiment sent to the contract.
        require(msg.value == _commitment, "The registration didn't receive the commitment.");
       
        //Check if the commitment is less than penalty
        require(_commitment >= taup, "The commitment should be greater than the penalty.");
       
        //Check if the required number of verifiers are already method
        require(numRegistered[_designNo] <= designes[_designNo].balance / taur, "No more registrations are accepted.");

        //Check if already registered
        require(regPlayers[_designNo][msg.sender] == 1, "Player already registered.");
        
        //Incrementing the player index and registration
        numRegistered[_designNo] += 1;
        regPlayers[_designNo][msg.sender] = 1;
    }
   
    function setReceived(uint256 _designNo, uint256 _playerNo)
        public payable
    {
        //Check if the sender is the manager responsible for secure exchange.
        require(msg.sender == designes[_designNo].manager, "Only manager can call this function.");
        
        players[_playerNo].received[_designNo] = true;
    }
   
    function commit(uint256 _designNo, uint256 _playerNo, bytes32 _cryptoCommitment, uint256 _timestamp)
        public
    {
        //Check if the player received the design and ready to vote.
        require(players[_playerNo].received[_designNo] == true, "The player can commit only when manager confirms design exchange.");
        
        //Check for expiry
        require(_timestamp <= designes[_designNo].timestamp + deltaExp, "The player cannot vote after expiry.");
        
        //Store the commitment by the player
        players[_playerNo].commitments[_designNo] = _cryptoCommitment;
    }
   
    function reveal(uint256 _designNo, uint256 _playerNo, bytes32 _vote, bytes32 _nonce, uint256 _timestamp)
        public
    {
        //Check for expiry. Beyond the expiry, the player revealing will have 
        //a picture of the voting trend and thus, can change for profit.
        require(_timestamp <= designes[_designNo].timestamp + deltaExp + deltaReveal, "The vote cannot be revealed after the expiry.");
        
        //Check the commitment
        require(players[_playerNo].commitments[_designNo] == keccak256(abi.encodePacked(_vote, _nonce)), "The player did not commit to this.");
        
        //Store the vote by the player
        players[_playerNo].votes[_designNo] = _vote;
    }

    function calculateResult(uint256 _designNo, uint256 _timestamp)
        public
    {
        //Check for expiry. The result cannot be calculated before the expiry.
        require(_timestamp > designes[_designNo].timestamp + deltaExp + deltaReveal, "The result cannot be revealed before the expiry.");
        
        //Calculate the weight
        
        //Calculate the result using formula 4 of the paper
        
        //Send deposite + or - the reward or penalty back to the researcher
        
        //Based on the result, update the reputation and weight.
        
        //Send the remaining deposite back to the vendor
        
        //Emit the notification for the result
        //emit tempOutput(totWeight);

    }
   
    //This is a helper function. This can be removed.
    function storedValue(uint256 index)
        public 
    {
        //emit tempOutput(designes[index].vendor, designes[index].timestamp, designes[index].expiry, now); //designes[index].balance);
    }
   
    //This is a utility function to extract ECDSA parameters from the signature.
    function splitSignature(bytes memory sig)
    public
    pure
    returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }
}
